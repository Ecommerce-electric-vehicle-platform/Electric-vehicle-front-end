import axiosInstance from "./axiosInstance";

/**
 * üîç T√¨m ki·∫øm s·∫£n ph·∫©m to√†n di·ªán t·ª´ BE
 * BE: GET /api/v1/products/search?q={query}&page={page}&size={size}
 */
export async function searchProducts({ query, page = 1, size = 50 } = {}) {
    if (!query || !query.trim()) {
        return {
            items: [],
            totalPages: 0,
            totalElements: 0,
            raw: null,
        };
    }

    try {
        const response = await axiosInstance.get("/api/v1/products/search", {
            params: {
                q: query.trim(),
                page: Math.max(0, page - 1), // BE d√πng 0-based page
                size
            },
        });

        const raw = response?.data ?? {};

        console.log("üîç Search API Response:", raw);

        // BE tr·∫£ d·∫°ng { success, message, data: { items: [...], meta: {...} } }
        const data = raw?.data || raw;

        const items = data?.items ||
            data?.content ||
            data?.results ||
            data?.list ||
            (Array.isArray(data) ? data : []);

        const totalPages = data?.meta?.totalPage ??
            data?.totalPages ??
            data?.page?.totalPages ??
            1;

        const totalElements = data?.meta?.totalElements ??
            data?.totalElements ??
            data?.page?.totalElements ??
            (Array.isArray(items) ? items.length : 0);

        return {
            items: Array.isArray(items) ? items : [],
            totalPages: Number(totalPages) || 1,
            totalElements: Number(totalElements) || 0,
            raw,
        };
    } catch (error) {
        console.error("‚ùå Search API Error:", error);

        // Fallback: t√¨m ki·∫øm trong t·∫•t c·∫£ s·∫£n ph·∫©m n·∫øu API search ch∆∞a c√≥
        try {
            const { items: allItems } = await fetchPostProducts({ page: 1, size: 100 });
            const allProducts = (allItems || []).map(normalizeProduct).filter(Boolean);

            const searchLower = query.toLowerCase();
            const filtered = allProducts.filter((item) => {
                return (
                    item.title.toLowerCase().includes(searchLower) ||
                    item.brand?.toLowerCase().includes(searchLower) ||
                    item.model?.toLowerCase().includes(searchLower) ||
                    item.locationTrading.toLowerCase().includes(searchLower) ||
                    item.description?.toLowerCase().includes(searchLower)
                );
            });

            return {
                items: filtered,
                totalPages: 1,
                totalElements: filtered.length,
                raw: null,
            };
        } catch (fallbackError) {
            console.error("‚ùå Fallback search error:", fallbackError);
            return {
                items: [],
                totalPages: 0,
                totalElements: 0,
                raw: null,
            };
        }
    }
}

/**
 * üîç T√¨m ki·∫øm nhanh (suggestions) - tr·∫£ v·ªÅ 5 k·∫øt qu·∫£ ƒë·∫ßu ti√™n
 */
export async function quickSearch(query) {
    if (!query || !query.trim()) return [];

    try {
        const { items } = await searchProducts({ query, size: 5 });
        return items;
    } catch (error) {
        console.error("‚ùå Quick search error:", error);
        return [];
    }
}

// Import normalizeProduct t·ª´ productApi
import { fetchPostProducts, normalizeProduct } from "./productApi";
